import GroebnerBasis

#------------------------------------------------------------------------------

function check_field_membership(
        generators::Array{<: Array{<: MPolyElem, 1}, 1},
        rat_funcs::Array{<: Any, 1},
        p::Float64;
        method="GroebnerBasis")
    """
    Checks whether given rational function belogn to a given field of rational functions
    Inputs:
        - generators - a list of lists of polynomials. Each of the lists, say, [f1, ..., fn],
          defines generators f2/f1, ..., fn/f1. Let F be the field generated by all of them.
        - rat_funcs - list rational functions
        - p - a real number between 0 and 1, the probability of correctness
    Output: a list L[i] of bools of length `length(rat_funcs)` such that L[i] is true iff
        the i-th function belongs to F. The whole result is correct with probability at least p
    """
    @debug "Finding pivot polynomials"
    pivots = map(plist -> min(map(poly -> (total_degree(poly), poly), plist)...)[2], generators)
    @debug "\tDegrees are $(map(total_degree, pivots))"

    @debug "Sampling the point"
    flush(stdout)
    ring = parent(first(first(generators)))

    total_lcm = foldl(lcm, pivots)
    total_lcm = foldl(lcm, map(f -> unpack_fraction(f)[2], rat_funcs); init=total_lcm)
    degree = total_degree(total_lcm) + 1
    for (i, plist) in enumerate(generators)
        extra_degree = total_degree(total_lcm) - total_degree(pivots[i])
        degree = max(degree, extra_degree + max(map(total_degree, plist)...))
    end
    for f in rat_funcs
        num, den = unpack_fraction(f)
        degree = max(degree, total_degree(total_lcm) - total_degree(den) + total_degree(num))
    end
    @debug "\tBound for the degrees is $degree"
    total_vars = foldl(
        union, 
        map(plist -> foldl(union, map(poly -> Set(vars(poly)), plist)), generators)
    )
    @debug "\tThe total number of variables in $(length(total_vars))"

    sampling_bound = 3 * BigInt(degree)^(length(total_vars) + 3) * length(rat_funcs) * ceil(1 / (1 - p))
    @debug "\tSampling from $(-sampling_bound) to $(sampling_bound)"
    point = map(v -> rand(-sampling_bound:sampling_bound), gens(ring))
    @debug "\tPoint is $point"

    @debug "Constructing the equations"
    eqs_sing = Array{Singular.spoly{Singular.n_Q}, 1}()
    ring_sing, vars_sing = Singular.PolynomialRing(
                               Singular.QQ, 
                               vcat(map(var_to_str, gens(ring)), ["sat_aux$i" for i in 1:length(generators)]);
                               ordering=:degrevlex
                           )

    for (i, component) in enumerate(generators)
        pivot = pivots[i]
        @debug "\tPivot polynomial is $(pivots)"
        eqs = []
        for poly in component
            push!(eqs, poly * evaluate(ring(pivot), point) - evaluate(ring(poly), point) * pivot)
        end
        append!(eqs_sing, map(p -> parent_ring_change(p, ring_sing), eqs))
        push!(
            eqs_sing,
            parent_ring_change(pivot, ring_sing) * vars_sing[end - i + 1] - 1
        )
    end

    @debug "Computing Groebner basis ($(length(eqs_sing)) equations)"
    flush(stdout)
    if method == "Singular"
        gb = Singular.std(Singular.Ideal(ring_sing, eqs_sing))
    elseif method == "GroebnerBasis"
        gb = GroebnerBasis.f4(Singular.Ideal(ring_sing, eqs_sing))
    else
        throw(Base.ArgumentError("Unknown method $method"))
    end

    @debug "Producing the result"
    flush(stdout)
    result = []
    for f in rat_funcs
        num, den = unpack_fraction(f)
        poly = num * evaluate(den, point) - den * evaluate(num, point)
        poly_sing = parent_ring_change(poly, ring_sing)
        push!(result, iszero(Singular.reduce(poly_sing, gb)))
    end
    return result
end

#------------------------------------------------------------------------------

function check_identifiability(
        io_equations::Array{P, 1}, 
        parameters::Array{P, 1},
        funcs_to_check::Array{<: Any, 1},
        p::Float64; 
        method="GroebnerBasis"
    ) where P <: MPolyElem{fmpq}
    """
    For the io_equation and the list of all parameter variables, returns a dictionary
    var => whether_globally_identifiable
    method can be "Singular" or "GroebnerBasis" yielding using Singular.jl or GroebnerBasis.jl
    """
    @debug "Extracting coefficients"
    flush(stdout)
    nonparameters = filter(v -> !(var_to_str(v) in map(var_to_str, parameters)), gens(parent(io_equations[1])))
    coeff_lists = Array{Array{P, 1}, 1}()
    for eq in io_equations
        push!(coeff_lists, collect(values(extract_coefficients(eq, nonparameters))))
    end
    for p in coeff_lists
        @debug sort(map(total_degree, p))
    end
    ring = parent(first(first(coeff_lists)))
    funcs_to_check = map(f -> parent_ring_change(f, ring), funcs_to_check)

    return check_field_membership(coeff_lists, funcs_to_check, p; method=method)
end

function check_identifiability(
        io_equation::P,
        parameters::Array{P, 1}, 
        funcs_to_check::Array{<: Any, 1}, 
        p::Float64; 
        method="GroebnerBasis"
    ) where P <: MPolyElem{fmpq}
    return check_identifiability([io_equation], parameters, funcs_to_check, p; method=method)
end

function check_identifiability(io_equations::Array{P, 1}, parameters::Array{P, 1}, p::Float64; method="GroebnerBasis") where P <: MPolyElem{fmpq}
    check_identifiability(io_equations, parameters, parameters, p; method=method)
end

function check_identifiability(io_equation::P, parameters::Array{P, 1}, p::Float64; method="GroebnerBasis") where P <: MPolyElem{fmpq}
    return check_identifiability([io_equation], parameters, p; method=method)
end

#------------------------------------------------------------------------------
# Experimental functionality

function (F::Singular.N_FField)(a::fmpq)
    return F(numerator(a)) // F(denominator(a))
end

function simplify_field_generators(generators::Array{<: Array{<: MPolyElem, 1}, 1})
    """
    Simplifies generators of a subfield of rational functions
    Inputs:
        - generators - a list of lists of polynomials. Each of the lists, say, [f1, ..., fn],
          defines generators f2/f1, ..., fn/f1. Let F be the field generated by all of them.
    Output: simplified generators of F
    """
    @debug "Finding pivot polynomials"
    pivots = map(plist -> min(map(poly -> (total_degree(poly), poly), plist)...)[2], generators)
    @debug "\tDegrees are $(map(total_degree, pivots))"

    total_vars = foldl(
        union, 
        map(plist -> foldl(union, map(poly -> Set(vars(poly)), plist)), generators)
    )
    total_vars = collect(total_vars)

    @debug "Constructing the equations"
    F, Fvars = Singular.FunctionField(Singular.QQ, map(var_to_str, total_vars))
    eqs_sing = Array{Singular.spoly{Singular.n_transExt}, 1}()
    ring_sing, vars_sing = Singular.PolynomialRing(
                               F, 
                               vcat(
                                    map(v -> var_to_str(v), total_vars),
                                    ["sat_aux$i" for i in 1:length(generators)]
                               );
                               ordering=:degrevlex
                           )
    base_to_coef = Dict(vars_sing[i] => Fvars[i] for i in 1:length(Fvars))

    for (i, component) in enumerate(generators)
        pivot = pivots[i]
        pivot_base = parent_ring_change(pivot, ring_sing)
        pivot_coef = eval_at_dict(pivot_base, base_to_coef)
        @debug "\tPivot polynomial is $(pivots)"
        for p in component
            p_base = parent_ring_change(p, ring_sing)
            p_coef = eval_at_dict(p_base, base_to_coef)
            push!(eqs_sing, p_base * pivot_coef - p_coef * pivot_base)
        end
        push!(
            eqs_sing,
            pivot_base * vars_sing[end - i + 1] - 1
        )
    end

    @debug "Computing Groebner basis ($(length(eqs_sing)) equations)"
    flush(stdout)
    gb = Singular.std(Singular.Ideal(ring_sing, eqs_sing))
    
    result = Set()

    for poly in gens(gb)
        denom = first(coeffs(poly))
        for c in coeffs(poly)
            if !(-c // denom in result)
                push!(result, c // denom)
            end
        end
    end

    return result
end

#------------------------------------------------------------------------------

function extract_identifiable_functions(io_equations::Array{P, 1}, parameters::Array{P, 1}) where P <: MPolyElem{fmpq}
    """
    For the io_equation and the list of all parameter variables, returns a dictionary
    var => whether_globally_identifiable
    method can be "Singular" or "GroebnerBasis" yielding using Singular.jl or GroebnerBasis.jl
    """
    @debug "Extracting coefficients"
    flush(stdout)
    nonparameters = filter(v -> !(var_to_str(v) in map(var_to_str, parameters)), gens(parent(io_equations[1])))
    coeff_lists = Array{Array{P, 1}, 1}()
    for eq in io_equations
        push!(coeff_lists, collect(values(extract_coefficients(eq, nonparameters))))
    end
    for p in coeff_lists
        @debug sort(map(total_degree, p))
    end

    return simplify_field_generators(coeff_lists)
end


